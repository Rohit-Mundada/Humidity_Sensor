DATA SEGMENT
    ; PORT ADDRESSES
    PORTA EQU 00H
    PORTB EQU 02H
    PORTC EQU 04H
    CONTROL_REG EQU 06H

    ; TEXT TO DISPLAY ON LCD
    HUMIDITY DB "Humidity: $"
    PPM DB "ppm$"

    ; VARIABLES TO KEEP TRACK OF PORT DATA
    PORTB_VAL DB 00H
    PORTC_VAL DB 00H

    ; MISC VARS
    QUOTIENT DB 31H
    REMAINDER DB 32H
    DECIMAL_POINT DB '.'
    MAX_PPM DB 56
ENDS

STACK SEGMENT
    DW 128 DUP(0)
ENDS

CODE SEGMENT
START:
    ; SETTING SEGMENT REGISTERS
    MOV AX, DATA
    MOV DS, AX
    MOV ES, AX

    ; INITIALISING 8255 WITH PORT-A AS INPUT PORT AND PORT-B, PORT-C AS OUTPUT PORTS
    MOV AL, 10010000B
    OUT CONTROL_REG, AL
    
    CALL LCD_INIT

    MOV DL, 01H
    MOV DH, 01H
    CALL LCD_SET_CUR

    ; GET DATA FROM ADC AND DISPLAY ON LCD
    CALL DISPLAY_HUMIDITY

    HLT
    ; END OF MAIN PROCEDURE

    ; ============= DISPLAY HUMIDITY VALUE PROCEDURE =============
PROC DISPLAY_HUMIDITY
    X1:
        IN AL, PORTA
        MOV QUOTIENT, AL
        
        CALL CHANGE_TO_PPM

        MOV AL, 00H
        OUT PORTC, AL

        MOV CX, 20000
        CALL DELAY

        MOV AL, 01H
        OUT PORTC, AL

        CALL LCD_CLEAR

        LEA SI, HUMIDITY
        CALL LCD_PRINTSTR

        MOV AH, QUOTIENT
        CALL LCD_WRITE_CHAR

        MOV AH, DECIMAL_POINT
        CALL LCD_WRITE_CHAR

        MOV AH, REMAINDER
        CALL LCD_WRITE_CHAR

        LEA SI, PPM
        CALL LCD_PRINTSTR

        MOV CX, 20000
        CALL DELAY

        JMP X1

    RET
ENDP DISPLAY_HUMIDITY


    ; ============= DELAY PROCEDURE =============
PROC DELAY
    ; HERE CX CONTROLS THE AMOUNT OF DELAY, CX=50 MEANS A DELAY OF 1 MS.
    JCXZ @DELAY_END
    @DEL_LOOP:
    LOOP @DEL_LOOP	
    @DELAY_END:
    RET
ENDP DELAY

    ; ============= ADC VALUE CONVERSION TO PPM VALUE =============
PROC CHANGE_TO_PPM
    ; QUOTIENT HAS THE VALUE TO BE CONVERTED INTO PPM
    ; LET VALUE FROM ADC BE X
    ; MAX_PPM STORES THE MAXIMUM PPM TO BE SHOWN * 10
    ; VALUE TO BE SHOWN IN PPM = (MAX_PPM) * X / 2550
    ; EG. X = 255 CORRESPONDS TO MAX_PPM
    ; DIGIT BEFORE DECIMAL IS STORED IN QUOTIENT
    ; DIGIT AFTER DECIMAL IS STORED IN REMAINDER
    MOV AL, QUOTIENT
    MOV AH, 00H ; AX = AH:AL

    MOV CL, MAX_PPM
    MOV CH, 00H
    MUL CX ; AX = AX * MAX_PPM

    MOV BX, 2550
    DIV BX ; AX = AX / 2550 AND DX = AX % 2550
    ; AX STORES THE QUOTIENT, DX STORES THE REMAINDER

    ADD AL, 30H ; CONVERTING HEX VALUE TO ASCII
    MOV QUOTIENT, AL ; STORING FIRST DECIMAL ASCII

    MOV AX, DX ; REMAINDER TRANSFERRED TO AX

    MOV CX, 10 
    MUL CX ; AX = AX * 10

    DIV BX ; AX = AX / 2550
    ; AX STORES THE QUOTIENT, FOR THIS CASE ALL THE QUOTIENTS ARE ONLY 8 BIT SO IT IS STORED IN AL

    ADD AL, 30H ; CONVERTING HEX VALUE TO ASCII
    MOV REMAINDER, AL ; STORING SECOND DECIMAL ASCII

    RET
ENDP CHANGE_TO_PPM

    ; ============= ALL LCD PROCEDURES INVOLVED =============
PROC LCD_INIT
    MOV AL, 01H
    CALL OUT_C ; MAKING LCD INPUT RS = RW = E = LOW (00H) AT THE START

    MOV CX, 1000
    CALL DELAY ; 20 MS DELAY

    ; RESET SEQUENCE
    MOV AH, 30H
    CALL LCD_CMD 

    MOV CX, 250
    CALL DELAY ; 250 MS DELAY

    MOV AH, 30H
    CALL LCD_CMD

    MOV CX, 50
    CALL DELAY ; 1 MS DELAY

    MOV AH, 30H
    CALL LCD_CMD

    MOV CX, 500
    CALL DELAY ; 10 MS DELAY

    ; SET FUNCTION
    MOV AH, 38H
    CALL LCD_CMD

    MOV AH, 0CH
    CALL LCD_CMD

    MOV AH, 01H
    CALL LCD_CMD

    MOV AH, 06H
    CALL LCD_CMD

    RET
ENDP LCD_INIT

PROC LCD_CMD
    ; AH CONTAINS THE COMMAND CODE
    PUSH DX
    PUSH AX
    
    MOV AL, PORTC_VAL
    AND AL, 0FDH ; RESET RS, AL = 1111 1101B, SINCE RS IS AT PIN PC1 OF 8255
    CALL OUT_C

    ; SET OUT DATA PINS
    MOV AL, AH
    CALL OUT_B

    MOV AL, PORTC_VAL
    OR AL, 1000B ; SET E, AL = 0000 1000B, SINCE EN IS AT PIN PC3 OF 8255
    CALL OUT_C

    MOV CX, 50
    CALL DELAY ; 1 MS DELAY

    MOV AL, PORTC_VAL
    AND AL, 0F7H ; RESET E, AL = 1111 0111B, SINCE E IS AT PIN PC3 OF 8255
    CALL OUT_C

    MOV CX, 50
    CALL DELAY ; 1 MS DELAY

    POP AX
    POP DX

    RET
ENDP LCD_CMD

PROC LCD_CLEAR
    MOV AH, 01H
    CALL LCD_CMD

    RET
ENDP LCD_CLEAR

PROC LCD_WRITE_CHAR
    ; AH CONTAINS THE INFO TO DISPLAY
    PUSH AX

    MOV AL, PORTC_VAL
    OR AL, 10B ; SET RS, AL = 0000 0010B, SINCE RS IS AT PIN PC1 OF 8255
    CALL OUT_C

    ; SET OUT DATA PINS
    MOV AL, AH
    CALL OUT_B

    MOV AL, PORTC_VAL
    OR AL, 1000B ; SET E, AL = 0000 1000B, SINCE EN IS AT PIN PC3 OF 8255
    CALL OUT_C

    MOV CX, 50
    CALL DELAY ; 1 MS DELAY

    MOV AL, PORTC_VAL
    AND AL, 0F7H ; RESET E, AL = 1111 0111B, SINCE E IS AT PIN PC3 OF 8255
    CALL OUT_C

    POP AX

    RET
ENDP LCD_WRITE_CHAR

PROC LCD_PRINTSTR
    ; SI CONTAINS THE ADDRESS OF THE STRING ENDING WITH '$'
    PUSH SI
    PUSH AX

    @LCD_PRINTSTR_LT:
        LODSB
        CMP AL, '$'
        JE @LCD_PRINTSTR_EXIT
        MOV AH, AL
        CALL LCD_WRITE_CHAR
    JMP @LCD_PRINTSTR_LT

    @LCD_PRINTSTR_EXIT:
        POP AX
        POP SI

    RET
ENDP LCD_PRINTSTR

PROC LCD_SET_CUR
    ; DH = ROW, DL = COL
    PUSH AX

    ; LCD USES 0 INDEXING FOR COLUMNS
    DEC DH

    ; DL = 1
    MOV AH, 80H
    JMP @LCD_SET_CUR_ENDCASE

    @LCD_SET_CUR_ENDCASE:
        ADD AH, DH
        CALL LCD_CMD

    POP AX

    RET
ENDP LCD_SET_CUR

PROC OUT_B
    ; AL CONTAINS THE DATA TO OUTPUT AND THIS IS STORED IN PORTB_VAL
    OUT PORTB, AL
    MOV PORTB_VAL, AL

    RET
ENDP OUT_B

PROC OUT_C
    ; AL CONTAINS THE DATA TO OUTPUT AND THIS IS STORED IN PORTC_VAL
    OUT PORTC, AL
    MOV PORTC_VAL, AL

    RET
ENDP OUT_C

CODE ENDS
END START